import * as _tag from './tag.js';
import * as _events from './events.js';
import * as _consumables from './consumables.js';
import * as _routing from './ext/routing.js';
export * from './tag.js';
export * from './state.js';
export * from './css-generator.js';
export * from './util.js';
export * from './text.js';
export * from './events.js';
export * from './each.js';
export * from './consumables.js';
export * from './ext/routing.js';
export type * from './types';
export declare const Cardboard: {
    isConsumable(obj: any): boolean;
    createConsumable<T>(val: T): _consumables.Consumable<T>;
    intersect<T_1, K>(other: import("./types").IConsumable<T_1>, intersector: (val: T_1) => K): import("./types").IConsumable<K>;
    greaterThan(consumable: import("./types").IConsumable<number>, val: number): import("./types").IConsumable<boolean>;
    greaterThanOr(consumable: import("./types").IConsumable<number>, val: number): import("./types").IConsumable<boolean>;
    lessThan(consumable: import("./types").IConsumable<number>, val: number): import("./types").IConsumable<boolean>;
    lessThanOr(consumable: import("./types").IConsumable<number>, val: number): import("./types").IConsumable<boolean>;
    equalTo<T_2>(consumable: import("./types").IConsumable<T_2>, val: T_2): import("./types").IConsumable<boolean>;
    notEqualTo<T_3>(consumable: import("./types").IConsumable<T_3>, val: T_3): import("./types").IConsumable<boolean>;
    isEmpty(consumable: import("./types").IConsumable<string | any[]>): import("./types").IConsumable<boolean>;
    notEmpty(consumable: import("./types").IConsumable<string | any[]>): import("./types").IConsumable<boolean>;
    Consumable: typeof _consumables.Consumable;
    makeRouter<T_4 extends Record<string, _routing.Route> = Record<string, _routing.Route>>(opts: _routing.RouterOptions<T_4>): _routing.Router<T_4>;
    Link(child: string | _tag.CTag, path: any, query?: Record<string, string> | undefined): _tag.CTag;
    Router: typeof _routing.Router;
    router: _routing.Router<any> | undefined;
    singleEvent<T_5>(): _events.CEvent<T_5>;
    mappedEvent<T_6>(): _events.CMappedEvent<T_6>;
    CEvent: typeof _events.CEvent;
    CMappedEvent: typeof _events.CMappedEvent;
    text(textTemplate: string, obj: import("./types").IConsumable<Record<string, import("./types").Primitive>> | Record<string, import("./types").IConsumable<import("./types").Primitive>>): Node;
    removeFromList<T_7>(item: T_7, list: T_7[]): boolean;
    isObject(obj: any): boolean;
    isArray(obj: any): boolean;
    arraysEqual(a: any[], b: any[]): boolean;
    isNumeric(str: any): boolean;
    camelToDash: (str: any) => any;
    dashToCamel: (str: any) => any;
    toJson: (possiblyJsonString: any) => any;
    fromJson: (possiblyJson: any) => string;
    val: <T_8>(val: T_8 | ((...args: any) => T_8), ...args: any[]) => T_8;
    swapItems: (array: any[], from: number, to: number) => any[];
    genCss(styleSheet: Record<string, import("./types").NestedStyleMap> | Record<string, import("./types").NestedStyleMap>[]): string;
    genBlock(selector: string, style: import("./types").NestedStyleMap): string;
    genBlockContent(selector: string, style: import("./types").NestedStyleMap): string[];
    genStyle(name: string, value: string): string;
    state<T_9>(initialValue: T_9): import("./types").IConsumable<T_9>;
    listState<T_10>(initialData: T_10[]): {
        readonly list: import("./types").IConsumable<import("./types").IConsumable<T_10>[]>;
        add: (item: T_10, complete?: boolean) => void;
        addAt: (item: T_10, index: number) => void;
        remove: (item: import("./types").IConsumable<T_10>) => void;
        length: import("./types").IConsumable<number>;
    };
    attached(): _tag.CTag | undefined;
    tag(arg0: string | HTMLElement, children?: import("./types").TagChildren, attach?: boolean): _tag.CTag;
    onLifecycle(tag: _tag.CTag, onStart?: ((tag: _tag.CTag) => boolean | Promise<boolean>) | undefined, onRemove?: ((tag: _tag.CTag) => void) | undefined, beforeRemove?: ((tag: _tag.CTag) => boolean | Promise<boolean>) | undefined): MutationObserver;
    attach(tag: _tag.CTag): _tag.CTag;
    detach(): void;
    detachAll(): void;
    init(options?: {
        root: string;
    }): _tag.CTag;
    CTag: typeof _tag.CTag;
    withLifecycle: (tag: _tag.CTag, handler: {
        start?: ((tag: _tag.CTag) => boolean | Promise<boolean>) | undefined;
        removed?: ((tag: _tag.CTag) => void) | undefined;
        beforeRemove?: ((tag: _tag.CTag) => boolean | Promise<boolean>) | undefined;
    }) => _tag.CTag;
    allTags: import("./types").AllTags;
};
