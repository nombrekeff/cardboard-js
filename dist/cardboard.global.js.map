{"version":3,"sources":["../src/cardboard.ts","../src/util.ts","../src/events.ts","../src/context.ts","../src/observables.ts","../src/text.ts","../src/tag.ts","../src/css-generator.ts","../src/style-manager.ts","../src/state.ts","../src/each.ts","../src/lifecycle.ts","../src/all-tags.ts"],"sourcesContent":["import * as _context from './context.js';\nimport * as _tag from './tag.js';\nimport * as _styles from './style-manager.js';\n\nexport * from './context.js';\nexport * from './tag.js';\nexport * from './state.js';\nexport * from './css-generator.js';\nexport * from './util.js';\nexport * from './text.js';\nexport * from './events.js';\nexport * from './each.js';\nexport * from './lifecycle.js';\nexport * from './observables.js';\nexport * from './all-tags.js';\nexport type * from './types';\n\n\n/**\n * It initializes the framework & makes the body tag the mount point ({@link mountPoint}).\n * You can pass in a selector for an element you want to be the default tag (\"body\" by default).\n */\nexport const init = (options: { selector: string } = { selector: 'body' }) => {\n  _context.context.init = true;\n  _context.context.obs = _context.createGlobalObserver();\n  _context.context.styleManager = new _styles.StyleManager();\n\n  const tag = new _tag.CTag(`(${options.selector})`);\n  return _context.mountPoint(tag);\n};\n\nexport const version = '0.0.7-alpha.2'; // This should be replaced with the actual version from package.json during the build process\n","/** Removes an item from an array if it exists. It returns whether it was removed or not */\nexport const removeFromList = <T>(item: T, list?: T[]) => {\n  if (!list) return false;\n\n  const index = list.indexOf(item);\n\n  if (index !== -1) {\n    list.splice(index, 1);\n    return true;\n  }\n\n  return false;\n};\n\nexport const camelToDash = str => str.replace(/([A-Z])/g, val => `-${val.toLowerCase()}`);\n\nexport const isObject = (obj: any): boolean => {\n  return typeof obj === 'object' && !(obj instanceof Array);\n};\nexport const isArray = (obj) => {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\nexport const val = <T>(val: T | ((...args: any) => T), ...args): T => {\n  if (typeof val === 'function') {\n    return (val as any)(...args);\n  }\n  return val;\n};\nexport const swapItems = (array: any[], from: number, to: number) => {\n  const temp = array[from];\n  array[from] = array[to];\n  array[to] = temp;\n  return array;\n};\nexport const arraysEqual = (a?: any[], b?: any[]) => {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  // If you don't care about the order of the elements inside\n  // the array, you should sort both arrays here.\n  // Please note that calling sort on an array will modify that array.\n  // you might want to clone your array first.\n\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\n/* eslint-disable  */\n/* istanbul ignore next */\nexport const deepEquals = (a, b) => {\n  if (a === b) return true;\n  if (a && b && a.length !== b.length) return false;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!deepEquals(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!deepEquals(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a !== a && b !== b;\n}\n\n/**\n * Generates a unique ID for a Cardboard tag.\n * If an `idNumber` is provided, it will return a string in the format `c_<idNumber>`.\n * If no `idNumber` is provided, it will generate a random UUID in the format `c_xxxxxxxxxx`.\n * \n * @returns A unique ID string for a Cardboard tag.\n */\nexport function generateUID(idNumber?: number): string {\n  if (!idNumber) return uuidv4();\n  return `c_${idNumber}`;\n}\n\nexport function uuidv4() {\n  return \"c_1000000010\".replace(/[018]/g, c =>\n    (+c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)\n  );\n}","import { removeFromList } from './util.js';\n\n/**\n * Single event listener/emitter, listen to, and trigger events. (for mapped events use {@link CMappedEvent}).\n *\n * @example\n * ```ts\n * const evt = new CEvent<bool>();\n * evt.listen(listener);\n * evt.dispatch(true);\n * evt.remove(listener);\n * ```\n */\nexport class CEvent<T> {\n  protected _lstrs: Array<(data: T | undefined) => void> = [];\n\n  listen(fn: (data?: T) => void) {\n    this._lstrs.push(fn);\n  }\n\n  remove(fn: (data?: T) => void) {\n    removeFromList(fn, this._lstrs);\n  }\n\n  dispatch(data?: T) {\n    this._lstrs.forEach((el) => el(data));\n  }\n\n  destroy() {\n    this._lstrs = [];\n  }\n}\n\n/**\n * Mapped event listener/emitter, listen to, and trigger events. (for single events use {@link CEvent}).\n *\n * @example\n * ```ts\n * const evt = new CMappedEvent<bool>();\n * evt.listen('evt', listener);\n * evt.dispatch('evt', true);\n * evt.remove('evt', listener);\n * ```\n */\n\nexport class CMappedEvent<T> {\n  private _lstrs: Record<string, Array<(data?: T) => void>> = {};\n\n  listen(evt: string, fn: (data?: T) => void) {\n    if (!(evt in this._lstrs)) {\n      this._lstrs[evt] = [fn];\n    }\n    else if (this._lstrs[evt]) {\n      this._lstrs[evt].push(fn);\n    }\n  }\n\n  remove(evt: string, fn: (data?: T) => void) {\n    removeFromList(fn, this._lstrs[evt]);\n  }\n\n  dispatch(evt: string, data?: T) {\n    if (evt in this._lstrs) {\n      this._lstrs[evt].forEach((el) => el(data));\n    }\n  }\n\n  destroy() {\n    this._lstrs = {};\n  }\n}\n\nexport const singleEvent = <T>() => {\n  return new CEvent<T>();\n};\n\nexport const mappedEvent = <T>() => {\n  return new CMappedEvent<T>();\n};\n","import { singleEvent, type CEvent } from \"./events.js\";\nimport { CTag } from \"./tag.js\";\nimport type { StyleManager } from \"./types.js\";\n\nexport type CardboardContext = {\n    intObs?: IntersectionObserver;\n    styleManager?: StyleManager;\n    mp?: CTag;\n    mpHistory: CTag[];\n    obs?: {\n        onAdded: CEvent<Node>;\n        onRemoved: CEvent<Node>;\n    };\n    init?: boolean;\n};\n\nexport const context: CardboardContext = {\n    mp: undefined,\n    mpHistory: [],\n    styleManager: undefined,\n    intObs: undefined,\n    obs: undefined,\n    init: false,\n};\n\nexport const isInitialized = () => context.init === true;\nexport const checkInitialized = () => {\n    if (!isInitialized()) {\n        throw new Error(\"Cardboard is not initialized. Please call `init()`, as some features will not work.\");\n    }\n};\n\n/**\n * Returns the current mountPoint {@link CTag}. See {@link mountPoint} for more information.\n */\nexport const getMountPoint = () => context.mp;\n\n/**\n * Makes the given tag the mount point. This means that when other tags are created with \"mountToParent\" or  (using `<tag_name>.mount()`, `tag('<tag_name>', [], true)`),\n * they will be added as children of this tag.\n * You can call mountPoint multiple times, and the last mount point tag will be used.\n * Then when you've finished, you can call {@link restoreMountPoint} to go back to the previously mounted tag if there is one.\n * You can clear all mount points using {@link clearMountPoints}.\n *\n * @example\n * ```ts\n * mountPoint(div()); // Div 1\n * div.mount();  // added as child of div\n * p.mount();    // added as child of div\n *\n * mountPoint(div()); // Div 2\n * div.mount();  // added as child of new div\n * p.mount();    // added as child of new div\n *\n * restoreMountPoint();      // Back to div 1\n * clearMountPoints();       // Clears all mount points, no mount point after this call\n * ```\n */\nexport const mountPoint = (tag: CTag) => {\n    if (context.mp) {\n        context.mpHistory.push(context.mp);\n    }\n    context.mp = tag;\n    return tag;\n};\n\n/**\n * Restore the currently mounted tag ({@link mountPoint}). \n * Goes back in the stack of mount points tags.\n * If there is no previous mount point tag, it will not do anything.\n */\nexport const restoreMountPoint = () => {\n    context.mp = context.mpHistory.pop();\n};\n\n/**\n * Restores all mount points. There will be no mount points tag after calling this function.\n */\nexport const clearMountPoints = () => {\n    context.mp = undefined;\n    context.mpHistory = [];\n};\n\n/**\n * Clears the mount point history and resets the mount point to the first one.\n * This means that the mount point will be the first tag that was mounted, \n * and all other mount points will be cleared.\n */\nexport const resetMountPoints = () => {\n    let first = context.mpHistory.shift();\n    context.mp = first;\n    context.mpHistory = [];\n};\n\nexport type ScopedCallback = (tag: CTag) => void;\n\n/**\n * Sets the mount point to the given tag, calls the scoped callback, and then restores the mount point.\n * Useful for creating a temporary mount point for a specific tag, and then restoring the previous mount point.\n * \n * @param tag \n * @param scopedCallback \n */\nexport const withMountPoint = (tag: CTag, scopedCallback: ScopedCallback) => {\n    mountPoint(tag);\n    scopedCallback(tag);\n    restoreMountPoint();\n}\n\n// TODO: Optimize this. Instead of observing everything, let lifecycles listen just to the parent of the element instead of everything.\nexport const createGlobalObserver = () => {\n    const _addedEvt = singleEvent<Node>();\n    const _removedEvt = singleEvent<Node>();\n\n    const observer = new window.MutationObserver((mutations, observer) => {\n        for (const mut of mutations) {\n            for (const n of Array.from(mut.addedNodes)) {\n                _addedEvt.dispatch(n);\n            }\n            for (const n of Array.from(mut.removedNodes)) {\n                _removedEvt.dispatch(n);\n            }\n        }\n    });\n\n    observer.observe(window.document.body, {\n        childList: true,\n        subtree: true,\n    });\n\n    return {\n        onAdded: _addedEvt,\n        onRemoved: _removedEvt,\n    };\n};","import { CEvent } from './events.js';\nimport { isArray, isObject } from './util.js';\nimport type { IObservable, IObservableOr, WithLength } from './types.js';\n\n/**\n * A class that holds a value and notifies whenever the value changes.\n * @see https://github.com/nombrekeff/cardboard-js/wiki/Observers\n */\nexport class Observable<T = any> extends CEvent<T> implements IObservable<T> {\n  private _value: T;\n  private readonly _destroyer?: () => void;\n\n  get value(): T {\n    return this._value;\n  }\n\n  /** Set the value, and dispatch to all listeners. */\n  set value(val: T) {\n    this.dispatch(val);\n  }\n\n  constructor(val: T, destroyer?: () => void) {\n    super();\n\n    if (val && (isObject(val) || isArray(val))) {\n      val = new Proxy((val as any), {\n        get(target, p, receiver) {\n          return target[p];\n        },\n        set: (target, p, newValue, receiver) => {\n          if (target[p] === newValue) return true;\n\n          target[p] = newValue;\n          super.dispatch(target);\n          return true;\n        },\n        deleteProperty: (target, p) => {\n          delete target[p];\n          super.dispatch(target);\n          return true;\n        },\n      });\n    }\n\n    this._value = val;\n    this._destroyer = destroyer;\n  }\n\n  valueOf() {\n    return this._value;\n  }\n\n  toString() {\n    return (this._value as any).toString();\n  }\n\n  /**\n   * Add a listener for when this Observable changes.\n   */\n  changed(callback: (val: T) => void) {\n    this.listen(callback);\n    return this;\n  }\n\n  /**\n  * Remove a listener for when this Observable changes.\n  */\n  remove(callback: (val: T) => void) {\n    super.remove(callback);\n    return this;\n  }\n\n  /**\n   * Set's the new value, and calls all the listeners.\n   * You can additionaly set the {@link value} directly.\n   */\n  dispatch(val: T) {\n    if (val === this._value) {\n      return this;\n    }\n    this._value = val;\n    super.dispatch(val);\n    return this;\n  }\n\n  destroy() {\n    if (this._destroyer) this._destroyer();\n    (this._value as any) = null;\n    super.destroy();\n  }\n\n  /**\n   * Creates a new {@link Observable} whose value is derived from another {@link Observable}.\n   * The new {@link Observable} automatically updates and notifies listeners whenever the source {@link Observable} changes.\n   *\n   * @example\n   * ```ts\n   * const value = createObservable(2);\n   * const isGreater = value.computed((value) => value > 5);\n   * // > isGreater == false;\n   * value.dispatch(6);\n   * // > isGreater == true;\n   * ```\n   */\n  computed = <K>(transform: (val: T) => K) => compute(this, transform);\n\n  /** @see {@link greaterThan} */\n  greaterThan = (val: IObservableOr<number> | number = 0) => greaterThan(this as any, val);\n  /** @see {@link greaterThanOr} */\n  greaterThanOr = (val: IObservableOr<number> = 0) => greaterThanOr(this as any, val);\n  /** @see {@link lessThan} */\n  lessThan = (val: IObservableOr<number> = 0) => lessThan(this as any, val);\n  /** @see {@link lessThanOr} */\n  lessThanOr = (val: IObservableOr<number> = 0) => lessThanOr(this as any, val);\n  /** @see {@link equalTo} */\n  equalTo = <K>(val: IObservableOr<K>) => equalTo(this as any, val);\n  /** @see {@link notEqualTo} */\n  notEqualTo = <K>(val: IObservableOr<K>) => notEqualTo(this as any, val);\n  /** @see {@link isEmpty} */\n  isEmpty = <K extends WithLength>() => isEmpty(this as any as IObservable<K>);\n  /** @see {@link notEmpty} */\n  notEmpty = <K extends WithLength>() => notEmpty(this as any as IObservable<K>);\n  /** @see {@link grab} */\n  grab = <K extends keyof T>(key: K, defaultVal?: T[K]) => grab(this as any, key, defaultVal);\n}\n\n/** \n * Check if a given object `obj` is a {@link Observable}  \n * * @param obj - The object to check.\n * @returns `true` if the object is an {@link Observable}, `false` otherwise\n */\nexport const isObservable = (obj: any) => {\n  return obj instanceof Observable;\n};\n\n/**\n * Create a new {@link Observable}  \n * > Consider using `state(...)` instead.\n * @see https://github.com/nombrekeff/cardboard-js/wiki/Observers\n * \n * @param val - The initial value of the observable.\n * @param destroyer - An optional function to call when the observable is destroyed.\n * @returns A new {@link Observable} instance.\n */\nexport const createObservable = <T>(val: T, destroyer?: () => void): IObservable<T> => {\n  return new Observable<T>(val, destroyer);\n};\n\n/**\n * Creates a new {@link Observable} whose value is derived from another {@link Observable}.\n * The new {@link Observable} automatically updates and notifies listeners whenever the source {@link Observable} changes.\n *\n * @param other - The source {@link Observable} to derive the value from.\n * @param transform - A function that takes the value of the source {@link Observable} and returns the derived value.\n * @return A new {@link Observable} that will contain the derived value.\n * \n * @example\n * ```ts\n * const value = createObservable(2);\n * // Create a derived observable that is true if value > 5\n * const isGreater = compute(value, (v) => v > 5);\n * // isGreater.value == false\n * value.dispatch(6);\n * // isGreater.value == true\n * ```\n */\nexport const compute = <T, K>(\n  other: IObservable<T>,\n  transform: (val: T) => K,\n): IObservable<K> => {\n  // eslint-disable-next-line prefer-const\n  let observable: IObservable<K> | null;\n\n  const cb = (val) => observable?.dispatch(transform(val));\n\n  observable = createObservable<K>(transform(other.value), () => {\n    // remove callback in other observable when destroyed\n    // remove references, free memory\n    other.remove(cb);\n    observable = null;\n    (other as any) = null;\n  });\n\n  other.changed(cb);\n\n  return observable as any;\n};\n\nexport type ExtractValue<T extends Array<IObservable<any>>> =\n  { [K in keyof T]: T[K] extends IObservable<infer V> ? V : never };\n\n/**\n * Computes a new {@link Observable} from multiple observables.\n * The new {@link Observable} will automatically update and notify listeners whenever any of the source observables change.\n * \n * @param observables - An array of source {@link Observable}s to derive the value from.\n * @param transform - A function that takes the values of the source observables and returns the derived value.\n * @returns A new {@link Observable} that will contain the derived value. \n */\nexport const computeMultiple = <T extends IObservable[], K>(\n  observables: [...T],\n  transform: (...v: [...ExtractValue<T>]) => K,\n): IObservable<K> => {\n  const cons = createObservable<K>(transform(...(observables.map(c => c.value) as any)));\n\n  for (const other of observables) {\n    other.changed(() => cons.dispatch(\n      transform(...(observables.map(c => c.value) as any))\n    ));\n  }\n  return cons as any;\n};\n\n/** Returns the value from an observable. Convenience method if you prefer it instead of `observable.value` */\nexport const getValue = <T>(val: IObservableOr<T>): T => {\n  return isObservable(val) ? (val as IObservable<T>).value : val as T;\n};\n\n/** {@link compute} an observable and return a new {@link Observable} indicating if the value is greater than `val` */\nexport const greaterThan = (observable: IObservable<number>, val: IObservable<number> | number = 0) => {\n  return compute(observable, (newVal) => newVal > getValue(val));\n};\n\n/** {@link compute} an observable and return a new {@link Observable} indicating if the value is greater than or equal `val` */\nexport const greaterThanOr = (observable: IObservable<number>, val: IObservableOr<number> = 0) => {\n  return compute(observable, (newVal) => newVal >= getValue(val));\n};\n\n/** {@link compute} an observable and return a new {@link Observable} indicating if the value is less than `val` */\nexport const lessThan = (observable: IObservable<number>, val: IObservableOr<number> = 0) => {\n  return compute(observable, (newVal) => newVal < getValue(val));\n};\n\n/** {@link compute} an observable and return a new {@link Observable} indicating if the value is less than or equal `val` */\nexport const lessThanOr = (observable: IObservable<number>, val: IObservableOr<number> = 0) => {\n  return compute(observable, (newVal) => newVal <= getValue(val));\n};\n\n/** {@link compute} an observable and return a new {@link Observable} indicating if the value is equal to `val` */\nexport const equalTo = <T>(observable: IObservable<T>, val: IObservableOr<T>) => {\n  return compute(observable, (newVal) => newVal === getValue(val));\n};\n\n/** {@link compute} an observable and return a new {@link Observable} indicating if the value is NOT equal to `val` */\nexport const notEqualTo = <T>(observable: IObservable<T>, val: IObservableOr<T>) => {\n  return compute(observable, (newVal) => newVal !== getValue(val));\n};\n\n/** {@link compute} an observable and return a new {@link Observable} indicating if the value is NOT empty */\nexport const isEmpty = <T extends WithLength>(observable: IObservable<T>) => {\n  return compute(observable, (newVal) => newVal.length <= 0);\n};\n\n/** {@link compute} an observable and return a new {@link Observable} indicating if the value is NOT empty */\nexport const notEmpty = <T extends WithLength>(observable: IObservable<T>) => {\n  return compute(observable, (newVal) => newVal.length > 0);\n};\n\n/** {@link compute} an observable and return a new {@link Observable} that is equal to some property of the original {@link Observable} */\nexport const grab = <T, K extends keyof T>(observable: IObservable<T>, key: K, defaultVal?: T[K]) => {\n  return compute(observable, (newVal) => newVal ? (newVal[key] ? newVal[key] : defaultVal) : defaultVal);\n};\n\n","import type { IObservable, Primitive, TextObj } from './types.js';\nimport { isObservable } from './observables.js';\nimport { isObject } from './util.js';\n\n/**\n * Create a **TextNode** from text, and optionally reacts to a {@link IObservable}, interpolating the defined variables in the text each time the state changes.\n *\n * If you provide a {@link IObservable} as the second argument, the text will act as a template\n * and can reference properties in the state: `$count`, `$someValue`.\n *\n * When the state properties changes, the text node will be automatically updated with the new text.\n * Only the properties that are referenced in the template will be listened to.\n *\n * **NOTE** If you're not interpolating, and dont need to change the text, you can directly pass in a string ('string') instead of (`text('string')`).\n *\n * @see https://github.com/nombrekeff/cardboard-js/wiki/Managing-Text\n *\n * @example\n * ```ts\n * const st = state({ count: 0 });\n *\n * p(text('Raw text!'));\n * p(text(`Count: $count`, st));\n * ```\n */\nexport const text = <T extends Record<string, Primitive>, K extends TextObj>(textTemplate: string, obj?: IObservable<T> | K): Node => {\n  const node = document.createTextNode(''),\n    interpolatePattern = /\\B\\$([0-9]+|[a-z][a-z0-9_$]*)/gi;\n\n  if (!obj) {\n    node.nodeValue = textTemplate;\n    return node;\n  }\n\n  const updateNode = (data: Record<string, Primitive>) => {\n    node.nodeValue = !data\n      ? textTemplate\n      : textTemplate.replace(interpolatePattern, (m, g1) =>\n        (data[g1] ?? m).toString(),\n      );\n  };\n\n  if (isObservable(obj)) {\n    (obj as IObservable<Record<string, any>>).changed((val) => updateNode(val));\n    updateNode((obj as IObservable).value);\n  }\n  else if (isObject(obj)) {\n    for (const key of Object.getOwnPropertyNames(obj)) {\n      // We're just interested in listening to the obj that are references in the text.\n      if (textTemplate.includes(`$${key}`) && isObservable(obj[key])) {\n        obj[key].changed(() => updateNode(obj as any));\n      }\n    }\n\n    updateNode(obj as any);\n  }\n\n  return node;\n};\n","import type {\n  IObservable,\n  NestedStyleMap,\n  NoOp,\n  Primitive,\n  StyleMap,\n  TagChild,\n  TagChildren,\n  TagConfig,\n  TextObj,\n} from './types';\nimport { CssProperty } from './css-properties.js';\nimport { PickPropertyValues } from './css-property-values.js';\nimport { TagName } from './tag-names.js';\nimport { val, camelToDash, uuidv4 } from './util.js';\nimport { text } from './text.js';\nimport { createObservable, isObservable } from './observables.js';\nimport { CommonAttributes } from './attributes.js';\nimport { checkInitialized, context } from './context.js';\n\n\n/**\n * This is the main class in Cardboard. Even though Cardboard is designed to not need to use this class directly, you can if you want.\n *\n * CTag contains a reference to an HTMLElement, its parent, and provides a set of methods to interact with it.\n */\nexport class CTag {\n  /** Reference to the HTMLElement that this @type {CTag} represents */\n  el: HTMLElement & { remove: () => (Promise<boolean> | any) };\n\n\n  private _visible = false;\n  get visible() {\n    return this._visible;\n  }\n\n  set visible(newValue: boolean) {\n    this._visible = newValue;\n    this.el.dispatchEvent(new CustomEvent('visible', {\n      detail: {\n        visible: newValue,\n        tag: this,\n      },\n      bubbles: true,\n      composed: true,\n    }));\n  }\n\n  /**\n   * Any function inside this array, will be called whenever the CTag is {@link destroy}ed\n   * Used to remove HTML Event Listeners and Observable listeners\n   * @hidden\n   */\n  private readonly _destroyers: NoOp[] = [];\n\n  /** @param parent Reference to the parent @type {CTag} of this element. */\n  private _parent?: CTag;\n\n  get parent(): CTag | undefined {\n    return this._parent;\n  }\n\n  set parent(newParent: CTag) {\n    this._parent = newParent;\n  }\n\n  /** Holds the list of all children, the ones that are currently in the DOM and those that are not. */\n  private _children: TagChild[] = [];\n\n  private _cachedChildren: Node[] = [];\n  get children() {\n    return this._getChildren(this.el);\n  }\n\n  private readonly _meta = {\n    isHidden: false,\n    nextSiblingID: null,\n  };\n\n  /**\n   * Gets the value of the `HTMLElement` that this CTag represents, if it has a value.\n   */\n  get value() {\n    return (this.el as any).value;\n  }\n\n  /**\n   * Sets the value of the `HTMLElement` that this CTag represents.\n   */\n  setValue(newValue?: string) {\n    (this.el as any).value = newValue;\n    return this;\n  }\n\n  /** \n   * Gets the checked state of the `HTMLElement` that this CTag represents, \n   * if it is a checkbox or radio button.\n   */\n  get checked() {\n    return (this.el as any).checked;\n  }\n\n  /** \n   * Sets the checked state of the element, if it is a checkbox or radio button.\n   */\n  setChecked(checked: boolean) {\n    (this.el as any).checked = checked;\n    return this;\n  }\n\n  /** \n   * Gets the style of the `HTMLElement` that this CTag represents.\n   */\n  get style() {\n    return this.el.style;\n  }\n\n  /** \n  * Gets the classname of the `HTMLElement` that this CTag represents.\n  */\n  get className() {\n    return this.el.className;\n  }\n\n  /** \n   * Gets the classlist of the `HTMLElement` that this CTag represents.\n   */\n  get classList() {\n    return this.el.classList;\n  }\n\n  /** Gets the value of the element and clears the value */\n  get consumeValue() {\n    const value = this.value;\n    this.clear();\n    return value;\n  }\n\n  /**\n   * Get's the id of the `HTMLElement` that this CTag represents.\n   */\n  get id() {\n    return this.el.id;\n  }\n\n  /**\n   * Set's the id of the `HTMLElement` that this CTag represents.\n   */\n  setId(id: string) {\n    this.el.id = id;\n    return this;\n  }\n\n  constructor(arg0: TagName | HTMLElement, children: TagChildren = [], mountToParent: boolean = false) {\n    const isSelector = typeof arg0 === 'string' && arg0.match(/\\(.+\\)/);\n\n    if (isSelector) {\n      const match = arg0.match(/\\(([\\.\\#]?[a-zA-Z][a-zA-Z0-9_$]+)\\)/);\n      const selector = match ? match[1] : null;\n      if (!selector) {\n        throw new Error(`'${arg0}' is not a valid selector`);\n      }\n\n      const element = document.querySelector(selector);\n\n      if (!element) {\n        throw new Error('Can\\'t find element for selector: ' + arg0);\n      }\n\n      this.el = element as HTMLElement;\n    }\n    else if (typeof arg0 === 'string') {\n      this.el = document.createElement(arg0);\n\n      if (context.mp && mountToParent) {\n        context.mp.append(this);\n      }\n    }\n    else if (arg0 instanceof HTMLElement) {\n      this.el = arg0;\n    }\n    else {\n      throw new Error('Invalid argument: ' + arg0);\n    }\n\n    if (children.length > 0) this.setChildren(children);\n\n    // Used by other parts of Cardboard to identify this tag\n    (this.el as any).tag = this;\n  }\n\n  /** \n   * Sets the children, removes previous children  \n   */\n  setChildren(children: TagChildren) {\n    this.el.replaceChildren(...this._mapChildren(children));\n    this._children = children;\n    return this;\n  }\n\n  // TODO: Consider if passing `children` as a single argument is better than spreading it.\n  /**\n   * Appends the given `children` to the element.\n   * \n   * @param {...TagChildren} children - The children to append to the element.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   * @example\n   * ```ts\n   * const tag = new CTag('div');\n   * tag.append(\n   *   new CTag('span', ['Child 1']),\n   *   new CTag('span', ['Child 2']),\n   * );\n   * ```\n   */\n  append(...children: TagChildren) {\n    this.el.append(...this._mapChildren(children));\n    this._children.push(...children);\n    return this;\n  }\n\n  /**\n   * Prepends the given `children` to the element.\n   * \n   * @param {...TagChildren} children - The children to append to the element.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   * @example\n   * ```ts\n   * const tag = new CTag('div');\n   * tag.prepend(\n   *   new CTag('span', ['Child 1']),\n   *   new CTag('span', ['Child 2']),\n   * );\n   * ```\n   */\n  prepend(...children: TagChildren) {\n    this.el.prepend(...this._mapChildren(children));\n    this._children.unshift(...children);\n    return this;\n  }\n\n  /**\n   * If the element is currently hidden it will add this element to the page wherever it's supposed to be.\n   * I will be placed exactly in the correct position, even if there are other elements hidden.\n   * **USE WITH CAUTION**: Not intended to be used in most cases.\n   * @hidden\n   */\n  async show() {\n    if (this.parent && !this.parent.children.includes(this.el)) {\n      const parentEl = this.parent.el;\n      // Get's the position of the element if all the children are visible\n      const expectedIndex = this.parent._children.indexOf(this);\n\n      // If the element should be the first child in the parent\n      if (expectedIndex === 0) {\n        parentEl.prepend(this.el);\n      }\n      // If the element should be the last child in the parent\n      else if (expectedIndex === this.parent._children.length - 1) {\n        parentEl.append(this.el);\n      }\n      // If the element should be the nth child in the parent\n      else {\n        // Calculate how many hidden children are before this element\n        let hiddenBefore = 0;\n        for (let i = expectedIndex - 1; i >= 0; i--) {\n          const child = this.parent._children[i];\n          if (child instanceof CTag && child._meta.isHidden) {\n            hiddenBefore++;\n          }\n        }\n\n        // Get the \"real\" children in the dom.\n        // The index takes into account the items that are hidden\n        const nextEl = parentEl.childNodes[expectedIndex - hiddenBefore];\n        parentEl.insertBefore(this.el, nextEl);\n      }\n    }\n    this._meta.isHidden = false;\n    return true;\n  }\n\n  /** \n   * Hide this element (removed from DOM) \n   * **USE WITH CAUTION**: Not intended to be used in most cases.\n   * @hidden\n   */\n  async hide() {\n    if (this.parent && this.parent.children.includes(this.el)) {\n      this.parent.el.insertBefore(document.createComment(this.el.id), this.el as any);\n      await this.remove();\n      this._meta.isHidden = true;\n    }\n  }\n\n  /** \n   * Whenever the `observable` changes, it will call the `callback`.\n   * This is helpful to react to changes in observables and update the tag accordingly.\n   * \n   * You can also do it directly, although you need to keep a reference to the tag yourself.\n   * \n   * @param observable - The observable to listen to.\n   * @param callback - The callback to call when the observable changes.\n   * @returns {CTag} - The current CTag instance, allowing for method chaining.\n   * \n   * @example\n   * ```ts\n   * const disabled = createObservable(false);\n   * const tag = new CTag('div');\n   * tag.consume(disabled, (self, isDisabled) => {\n   *   console.log('New value:', isDisabled);\n   *   self.setDisabled(isDisabled);\n   * });\n   * ```\n   */\n  consume<T>(observable: IObservable<T>, callback: (self: CTag, newValue?: T) => void) {\n    if (observable.changed) {\n      const cb = (newValue) => callback(this, newValue);\n      observable.changed(cb);\n\n      this._destroyers.push(() => {\n        // Destroy reference to the observable, we don't need it anymore\n        observable.remove(cb);\n        (observable as any) = null;\n      });\n    }\n    else {\n      console.warn('An invalid Observable was supplied to `tag.consume`');\n    }\n\n    callback(this, ('value' in observable) ? observable.value : observable);\n    return this;\n  }\n\n  /**\n   * When the observable changes, it will call `ifTrue` when the observable is true. Or `ifFalse` when the observable is false.\n   * If `invert` is set to true, the condition will be inversed, but you can also use {@link doIfNot}\n   * \n   * @param {IObservable} observable - The observable to listen to.\n   * @param {function} ifTrue - The function to call when the observable is truey.\n   * @param {function} ifFalse - The function to call when the observable is falsey.\n   * @param {boolean} [invert=false] - If true, the condition will be inversed.\n   * @returns {CTag} - The current CTag instance, allowing for method chaining.\n   */\n  doIf<T>(observable: IObservable<T>, ifTrue: (value?: T) => void, ifFalse: (value?: T) => void, invert = false) {\n    if (invert) {\n      const temp = ifTrue;\n      ifTrue = ifFalse;\n      ifFalse = temp;\n    }\n\n    const callback = (_, value) => {\n      // eslint-disable-next-line no-extra-boolean-cast\n      if (!!value) ifTrue(value);\n      else ifFalse(value);\n    };\n\n    return this.consume(observable, callback);\n  }\n\n  /**\n   * The oposite of {@link doIf}\n   * When the observable changes, it will call `ifTrue` if the observable is false. Or `ifFalse` if the observable is true.\n   * \n   * @param {IObservable} observable - The observable to listen to.\n   * @param {function} ifTrue - The function to call when the observable is falsy.\n   * @param {function} ifFalse - The function to call when the observable is truthy.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   */\n  doIfNot<T>(observable: IObservable<T>, ifTrue: (value: T) => void, ifFalse: (value: T) => void) {\n    return this.doIf(observable, ifTrue, ifFalse, true);\n  }\n\n  /**\n   * Hide this element when the consumer is truthy. Updates whenever the observable changes.\n   * If `invert` is set to true, the condition will be inversed, but you can also use {@link hideIfNot}\n   * \n   * @param {IObservable} observable - The observable to listen to.\n   * @param {boolean} [invert=false] - If true, the condition will be inversed.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   * \n   * @example\n   * ```ts\n   * const isHidden = createObservable(false);\n   * const tag = new CTag('div');\n   * tag.hideIf(isHidden); // Hides the tag when isHidden is true\n   * ```\n   */\n  hideIf<T>(observable: IObservable<T>, invert = false) {\n    const handleHide = (_, value: any) => {\n      const correctedValue = invert ? !value : !!value;\n      this._meta.isHidden = correctedValue;\n\n      if (!this.parent) return;\n      if (!correctedValue) void this.show();\n      else void this.hide();\n    };\n\n    return this.consume(observable, handleHide);\n  }\n\n  /** \n   * Hide this element when the `observable` is falsy. Updates whenever the `observable` changes. \n   * \n   * @param {IObservable} observable - The observable to listen to.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   * \n   * @example\n   * ```ts\n   * const isVisible = createObservable(false);\n   * const tag = new CTag('div');\n   * tag.hideIfNot(isVisible); // Hides the tag when isVisible is false\n   * ```\n   */\n  hideIfNot<T>(observable: IObservable<T>) {\n    return this.hideIf(observable, true);\n  }\n\n  /**\n   * Adds classes to the element when the `observable` is truthy, and removes them when it is falsy.\n   * Updates whenever the `observable` changes.\n   * You can pass in an array of classes, or a function that returns a list of classes.\n   * If `invert` is set to true, the condition will be inversed, but you can also use {@link classIfNot}\n   * \n   * @param {IObservable} observable - The observable to listen to.\n   * @param {string[] | ((self: CTag) => string[])} classes - The classes to add to the element. Can be an array of strings or a function that returns an array of strings.\n   * @param {boolean} [invert=false] - If true, the condition will be inversed.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   * \n   * @example\n   * ```ts\n   * const isActive = createObservable(true);\n   * const tag = new CTag('div');\n   * \n   * // Adds 'active' and 'highlighted' classes when isActive is true\n   * tag.classIf(isActive, ['active', 'highlighted']); \n   * ```\n   */\n  classIf<T>(observable: IObservable<T>, classes: string[] | ((self: CTag) => string[]), invert = false) {\n    return this.doIf(\n      observable,\n      () => this.addClass(...val(classes, this)),\n      () => this.rmClass(...val(classes, this)),\n      invert,\n    );\n  }\n\n  /**\n   * Adds classes to the element when the `observable` is falsy, and removes them when it is truthy.\n   * Updates whenever the `observable` changes.\n   * You can pass in an array of classes, or a function that returns a list of classes.\n   * \n   * @param {IObservable} observable - The observable to listen to.\n   * @param {string[] | ((self: CTag) => string[])} classes - The classes to add to the element. Can be an array of strings or a function that returns an array of strings.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   * \n   * @example\n   * ```ts\n   * const isActive = createObservable(true);\n   * const tag = new CTag('div');\n   * \n   * // Adds 'inactive' classes when isActive is false\n   * tag.classIfNot(isActive, ['inactive']); \n   * ```\n   */\n  classIfNot<T>(observable: IObservable<T>, classes: string[] | ((self: CTag) => string[])) {\n    return this.classIf(observable, classes, true);\n  }\n\n  /**\n   * Sets `text` when the consumer is true, and sets `elseText (default='')` when the consumer is false.\n   * Both `text` and `elseText` can be a string or a function that returns a string.\n   * Updates whenever the observable changes.\n   * If `invert` is set to true, the condition will be inversed, but you can also use {@link textIfNot}\n   * \n   * @param {IObservable} observable - The observable to listen to.\n   * @param {string | ((self: CTag) => string)} text - The text to set when the observable is truthy. Can be a string or a function that returns a string.\n   * @param {string | ((self: CTag) => string)} [elseText=''] - The text to set when the observable is falsy. Can be a string or a function that returns a string. Defaults to an empty string.\n   * @param {boolean} [invert=false] - If true, the condition will be inversed.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   */\n  textIf<T>(\n    observable: IObservable<T>,\n    text: string | ((self: CTag) => string),\n    elseText: string | ((self: CTag) => string) = '',\n    invert = false,\n  ) {\n    return this.doIf(\n      observable,\n      () => this.text(val(text, this)),\n      () => this.text(val(elseText, this)),\n      invert,\n    );\n  }\n\n  /**\n   * Sets text when the consumer is falsy, and sets `elseText (default='')` when the consumer is truthy.\n   * Both text and `elseText` can be a string or a function that returns a string.\n   * Updates whenever the observable changes.\n   */\n  textIfNot<T>(\n    observable: IObservable<T>,\n    text: string | ((self: CTag) => string),\n    elseText: string | ((self: CTag) => string) = '',\n  ) {\n    return this.textIf(observable, text, elseText, true);\n  }\n\n  /**\n   * Add attribute to the element when the consumer is truthy. Updates whenever the observable changes.\n   * `value` can be a string or a function that returns a string.\n   * If `invert` is set to true, the condition will be inversed, but you can also use {@link attrIfNot}\n   */\n  attrIf<T>(observable: IObservable<T>, attr: CommonAttributes, value: string | ((self: CTag) => string) = '', invert = false) {\n    return this.doIf(\n      observable,\n      () => this.addAttr(attr, val(value, this)),\n      () => this.rmAttr(attr),\n      invert,\n    );\n  }\n\n  /**\n   * Add attribute to the element when the consumer is falsy. Updates whenever the observable changes.\n   * `value` can be a string or a function that returns a string.\n   * If `invert` is set to true, the condition will be inversed\n   */\n  attrIfNot<T>(observable: IObservable<T>, attr: CommonAttributes, value: string | ((self: CTag) => string) = '') {\n    return this.attrIf(observable, attr, value, true);\n  }\n\n  /**\n   * Disable this element when the consumer is truthy. Updates whenever the observable changes.\n   * If `invert` is set to true, the condition will be inversed, but you can also use {@link disableIfNot}\n   */\n  disableIf<T>(observable: IObservable<T>, invert = false) {\n    return this.attrIf(observable, 'disabled', '', invert);\n  }\n\n  /** Disable this element when the consumer is falsy. Updates whenever the observable changes. */\n  disableIfNot<T>(observable: IObservable<T>) {\n    return this.disableIf(observable, true);\n  }\n\n  /**\n   * Add style to the element when the consumer is truthy. Updates whenever the observable changes.\n   * If `invert` is set to true, the condition will be inversed, but you can also use {@link styleIfNot}\n   * `value` can be a string or a function that returns a string.\n   */\n  styleIf<T>(observable: IObservable<T>, style: string, value: string | ((self: CTag) => string) = '', invert = false) {\n    return this.doIf(\n      observable,\n      () => this.addStyle(style, val(value, this)),\n      () => this.rmStyle(style),\n      invert,\n    );\n  }\n\n  /**\n   * Add style to the element when the consumer is falsy. Updates whenever the observable changes.\n   * `value` can be a string or a function that returns a string.\n   */\n  styleIfNot<T>(observable: IObservable<T>, style: string, value: string | ((self: CTag) => string) = '') {\n    return this.styleIf(observable, style, value, true);\n  }\n\n  /**\n   * Add multiple styles to the element when the consumer is truthy. Updates whenever the observable changes.\n   * `styles` can be a {@link StyleMap} or a function that returns a {@link StyleMap}.\n   * If `invert` is set to true, the condition will be inversed, but you can also use {@link stylesIfNot}\n   */\n  stylesIf<T>(observable: IObservable<T>, styles: StyleMap | ((self: CTag) => StyleMap), invert = false) {\n    return this.doIf(\n      observable,\n      () => this.setStyle(val(styles, this)),\n      () => this.rmStyle(...Object.keys(styles)),\n      invert,\n    );\n  }\n\n  /**\n   * Add multiple styles to the element when the consumer is falsy. Updates whenever the observable changes.\n   * `styles` can be a {@link StyleMap} or a function that returns a {@link StyleMap}.\n   * For the oposite use  {@link stylesIf}\n   */\n  stylesIfNot<T>(observable: IObservable<T>, styles: StyleMap | ((self: CTag) => StyleMap)) {\n    return this.stylesIf(observable, styles, true);\n  }\n\n  /**\n   * Adds a `stylesheet` to main style manager, and adds the `className` to the element.\n   * This is useful for adding styles to the element that are not inline styles.\n   * By doing this we can have just one style definition for tags that will have the same styles.\n   * \n   * @see https://github.com/nombrekeff/cardboard-js/wiki/Styling#6-advanced-styling-child-elements\n   * \n   * @param {NestedStyleMap} stylesheet - The stylesheet to add to the style manager.\n   * @param {string} [className] - The class name to add to the element. If not provided, a random UUID will be generated.\n   * @return {CTag} - The current CTag instance, allowing for method chaining.\n   */\n  styled(stylesheet: NestedStyleMap | undefined, className?: string): CTag {\n    // TODO(nombrekeff): sanitizing className might be a good idea\n    className ??= uuidv4();\n\n    if (stylesheet) {\n      context.styleManager?.add({\n        [`.${className}`]: stylesheet,\n      });\n    }\n\n    return this.addClass(className);\n  }\n\n  /**\n   * If {textTemplate} is provided, it sets the `textContent` of the element.\n   * If {textTemplate} is provided, and a state is provided. It will use the {textTemplate} as a template,\n   * that will be interpolated with the values in the state, each time the state changes. It acts like {@link text}\n   *\n   * If no argument is provided, it returns the `textContent` of the element.\n   * @see https://github.com/nombrekeff/cardboard-js/wiki/Managing-Text\n   */\n  text<T extends Record<string, Primitive>, K extends TextObj, J extends string>(textTemplate?: string, obj?: IObservable<T> | K): J extends string ? CTag : string {\n    if (textTemplate == null) {\n      return this.el.textContent as any;\n    }\n\n    if (obj && textTemplate) {\n      return this.setChildren([text(textTemplate, obj)]) as any;\n    }\n\n    this.el.textContent = textTemplate;\n\n    return this as any;\n  }\n\n  /**\n   * Configure the element in a single call by passing @param {TagConfig} c\n   * instead of having to call a method for each property you want to change\n   * \n   * @param {TagConfig} c - The configuration object containing properties to set on the element.\n   * @returns {CTag} - The current CTag instance, allowing for method chaining\n   * \n   * @example\n   * ```ts\n   * const tag = new CTag('div');\n   * tag.config({\n   *   attr: { id: 'my-div', 'data-custom': 'value' },\n   *   classList: ['class1', 'class2'],\n   *   className: 'my-class',\n   *   style: { color: 'red', backgroundColor: 'blue' },\n   *   text: 'Hello World',\n   *   value: 'Initial Value',\n   *   children: [new CTag('span', ['Child Text'])],\n   *   on: {\n   *     click: (self, evt) => console.log('Clicked!', self),\n   *   },\n   * });\n   * ```\n   */\n  config(c: TagConfig) {\n    if (c.attr) this.setAttrs(c.attr);\n    if (c.classList) this.addClass(...c.classList);\n    if (c.className) this.setClassName(c.className);\n    if (c.style) this.setStyle(c.style);\n    if (c.text) this.text(c.text);\n    if (c.value) this.setValue(c.value);\n    if (c.children) this.append(...c.children);\n    if (c.on) {\n      for (const key of Object.keys(c.on)) {\n        this.on(key, c.on[key]);\n      }\n    }\n\n    return this;\n  }\n\n  /** \n   * Add classes to the elements class list.\n   * \n   * @param {...string} classes - The classes to add to the element's class list.\n   * @returns {CTag} - The current CTag instance, allowing for method chaining\n   * \n   * @example\n   * ```ts\n   * const tag = new CTag('div');\n   * tag.addClass('class1', 'class2');\n   * ```\n   */\n  addClass(...classes: string[]) {\n    this.classList.add(...classes);\n    return this;\n  }\n\n  /** Set the elements class name */\n  setClassName(className: string) {\n    this.el.className = className;\n    return this;\n  }\n\n  /** Remove classes from class list */\n  rmClass(...classes: string[]) {\n    for (const key of classes) {\n      this.classList.remove(key);\n    }\n    return this;\n  }\n\n  /** Check if classes are present in this element */\n  hasClass(...classes: string[]) {\n    for (const key of classes) {\n      if (!this.classList.contains(key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** Replace a class with another */\n  replaceClass(targetClass: string, replaceClass: string) {\n    this.classList.replace(targetClass, replaceClass);\n    return this;\n  }\n\n  /** Toggle a class. If it's present it's removed, if it's not present its added. */\n  toggleClass(targetClass: string): CTag {\n    return this.hasClass(targetClass) ? this.rmClass(targetClass) : this.addClass(targetClass);\n  }\n\n  /** Add a single style */\n  addStyle<K extends CssProperty>(property: K, value: PickPropertyValues<K>) {\n    this.el.style[property as string] = value;\n    return this;\n  }\n\n  /** Set multiple styles at once */\n  setStyle(styles: StyleMap) {\n    for (const key in styles) {\n      this.addStyle(key, styles[key] ?? '');\n    }\n    return this;\n  }\n\n  /** Remove styles */\n  rmStyle(...styleNames: string[]) {\n    for (const key of styleNames) {\n      this.style.removeProperty(camelToDash(key));\n    }\n    return this;\n  }\n\n  /** Check if this element has styles */\n  hasStyle(...styles: CssProperty[]) {\n    for (const key of styles) {\n      if (!this.style.getPropertyValue(camelToDash(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** Adds a set of attributes to the element */\n  setAttrs(attrs: Record<string, string | undefined>) {\n    for (const key in attrs) {\n      this.addAttr(key, attrs[key]);\n    }\n    return this;\n  }\n\n  /** Adds a single attribute to the element */\n  addAttr(key: CommonAttributes, value: string = '') {\n    this.el.attributes[key as string] = value;\n    this.el.setAttribute(key, value);\n    return this;\n  }\n\n  /** Remove attributes from the element */\n  rmAttr(...attrs: CommonAttributes[]) {\n    for (const key of attrs) {\n      this.el.removeAttribute(key);\n      delete this.el.attributes[key];\n    }\n    return this;\n  }\n\n  /** Check if this element has attributes */\n  hasAttr(...attr: CommonAttributes[]) {\n    for (const key of attr) {\n      if (!(key in this.el.attributes)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** Get an attributes value */\n  getAttr(attr: CommonAttributes) {\n    return this.el.attributes[attr];\n  }\n\n  // TODO: Might be a good idea to return the listener so it can be removed later\n  /**\n   * Listen to an event on the element. Like addEventListener.\n   */\n  listen<K extends keyof HTMLElementEventMap>(\n    tag: CTag,\n    evt: K,\n    consumer: (self: CTag, other: CTag, evt: HTMLElementEventMap[K]) => void,\n  ) {\n    return tag.on(evt, (other, evt) => {\n      consumer(this, other, evt);\n    });\n  }\n\n  /**\n   * Returns a {@link IObservable} that fires when the Event `evtName` is fired in this element\n   * The return value of `fn` will be passed to the listeners of the {@link IObservable}\n   * \n   * @param {K} evtName - The name of the event to listen for. For a list of valid event names, see {@link HTMLElementEventMap \"available event names\"}.\n   * @param {fn} fn - The callback function to execute when the event is triggered.\n   * @returns {IObservable<any>} - An observable that emits the return value of the callback function when the event is triggered.\n   */\n  when<K extends keyof HTMLElementEventMap>(\n    evtName: K | string,\n    fn: (self: CTag, evt: HTMLElementEventMap[K]) => any,\n  ): IObservable<any> {\n    const cons = createObservable<any>({});\n    this.on(evtName, (t, evt) => {\n      cons.dispatch(fn(t, evt));\n    });\n    return cons;\n  }\n\n  // TODO: Might be a good idea to return the listener so it can be removed later\n  /** \n   * Add an event listener for a particular HTMLElement event \n   * \n   * @param {K} evtName - The name of the event to listen for. For a list of valid event names, see {@link HTMLElementEventMap \"available event names\"}.\n   * @param {fn} fn - The callback function to execute when the event is triggered.\n   * @returns {CTag} - The current CTag instance, allowing for method chaining\n   */\n  on<K extends keyof HTMLElementEventMap>(\n    evtName: K | string,\n    fn: (tag: CTag, evt: HTMLElementEventMap[K]) => void\n  ): CTag {\n    if (fn) {\n      const cb = (evt: any) => fn(this, evt);\n      this.el.addEventListener(evtName, cb);\n      this._destroyers.push(() => {\n        this.el.removeEventListener(evtName, cb);\n      });\n    }\n    return this;\n  }\n\n  /** \n   * Add an event listener for a particular event that will only fire once\n   * @param {K} evtName - The name of the event to listen for. For a list of valid event names, see {@link HTMLElementEventMap \"available event names\"}.\n   * @param {fn} fn - The callback function to execute when the event is triggered.\n   * @returns {CTag} - The current CTag instance, allowing for method chaining\n   */\n  once<K extends keyof HTMLElementEventMap>(\n    evtName: K & string,\n    fn: (tag: CTag, evt: HTMLElementEventMap[K]) => void\n  ): CTag {\n    const listener = (evt) => {\n      fn(this, evt);\n      this.el.removeEventListener(evtName, listener);\n    };\n    this.el.addEventListener(evtName, listener);\n    return this;\n  }\n\n  // TODO: nombrekeff: maybe remove these convenience methods. Would free some space in the bundle\n  /** Add a **click** event listener */\n  clicked(fn: (tag: CTag, evt: MouseEvent) => void): CTag {\n    return this.on('click', fn);\n  }\n\n  /** Add a **keypress** event listener */\n  keyPressed(fn: (tag: CTag, evt: KeyboardEvent) => void, key?: string): CTag {\n    if (key) {\n      return this.on('keypress', (_, evt) => {\n        if (evt.code === key || evt.key === key) {\n          fn(this, evt);\n        }\n      });\n    }\n\n    return this.on('keypress', fn);\n  }\n\n  /** Add a **change** event listener */\n  changed(fn: (tag: CTag, evt: Event) => void): CTag {\n    return this.on('change', fn);\n  }\n\n  /** Add a **submit** event listener */\n  submited(fn: (tag: CTag, evt: SubmitEvent) => void): CTag {\n    return this.on('submit', fn);\n  }\n\n  /**\n   * Remove element from the DOM, but keep data as is. Can then be added again.\n   * To fully remove the element use {@link destroy}\n   * \n   * **USE WITH CAUTION!** Not intended to be used in most cases.\n   */\n  async remove(): Promise<CTag> {\n    // Might be a promise (it's overriden by `withLifecycle`)\n    const result: any = this.el.remove();\n    if (result instanceof Promise) {\n      await result;\n    }\n\n    await (this.el as any).remove();\n    return this;\n  }\n\n  /**\n   * Destroy the element, should not be used afterwards\n   * \n   * **USE WITH CAUTION!** Not intended to be used in most cases.\n   */\n  destroy(): void {\n    context.intObs?.unobserve(this.el);\n    this._children.forEach((cl) => {\n      if (cl instanceof CTag) {\n        cl.destroy();\n      }\n    });\n\n    this._destroyers.forEach(listener => listener());\n    this._children = [];\n    this._cachedChildren = [];\n    void this.remove();\n  }\n\n  /**\n   * Clears the `value` of the element. If you are getting the value and then clearing, consider using {@link consumeValue}\n   */\n  clear(): CTag {\n    (this.el as any).value = '';\n    // Trigger input event, so clearing is treated as input!\n    this.el.dispatchEvent(new InputEvent('input'));\n    return this;\n  }\n\n  /** Disable the element */\n  disable(): CTag {\n    return this.setDisabled(true);\n  }\n\n  /** Enable the element */\n  enable(): CTag {\n    return this.setDisabled(false);\n  }\n\n  /** \n   * Set whether the element should be disabled or not. It sets the `disabled` attribute.\n   */\n  setDisabled(disabled: boolean): CTag {\n    return disabled ? this.addAttr('disabled') : this.rmAttr('disabled');\n  }\n\n  /** \n   * Query a child in this element (in the DOM)\n   * \n   * @param {string} selector - The CSS selector to query the child element.\n   * @returns {CTag | undefined} - Returns a CTag instance if the element is found, or undefined if not found.\n   * \n   * @example\n   * ```ts\n   * const childTag = parentTag.q('.child-class');\n   * ```\n   */\n  q(selector): CTag | undefined {\n    const element = this.el.querySelector(selector);\n    if (element) return new CTag(element);\n  }\n\n  /** \n   * Find a child in this element (in the DOM or NOT)\n   * @param {function} predicate - A function that takes a TagChild and returns true if it matches the condition.\n   * @returns {TagChild | undefined} - Returns the first TagChild that matches the predicate, or undefined if no match is found.\n   */\n  find(predicate: (el: TagChild) => boolean): TagChild | undefined {\n    for (const child of this._children) {\n      if (predicate(child)) {\n        return child;\n      }\n    }\n  }\n\n  /**\n   * Find a CTag child in this element (in the DOM or NOT)\n   * @param {function} predicate - A function that takes a CTag and returns true if it matches the condition.\n   * @returns {CTag | undefined} - Returns the first CTag that matches the predicate, or undefined if no match is found.\n   */\n  findTag(predicate: (el: CTag) => boolean): CTag | undefined {\n    for (const child of this._children) {\n      if (child instanceof CTag && predicate(child)) {\n        return child;\n      }\n    }\n  }\n\n\n  private _childrenFilterPredicate(item) {\n    if (item instanceof CTag && item._meta.isHidden) {\n      return false;\n    }\n    return true;\n  }\n\n\n  private _getElementForChild(cl: TagChild): Node | null {\n    if (typeof cl === 'string') return document.createTextNode(cl);\n    if (isObservable(cl)) {\n      return text('$val', { val: (cl as IObservable) });\n    }\n    if (cl instanceof CTag) return cl.el;\n    if (cl instanceof Node) return cl;\n    return null;\n  }\n\n  // Update cached child nodes whenever this elements childs change\n  // This makes it a lot faster to get children.\n  // If the children have not changed, there's no need to set the children, use the previous ones\n\n  private _observer: MutationObserver;\n\n  private _getChildren(element: HTMLElement) {\n    if (!this._observer) {\n      this._observer = new window.MutationObserver(() => {\n        this._cacheChildren(element);\n      });\n      this._observer.observe(this.el, { childList: true });\n      this._cacheChildren(element);\n    }\n    return this._cachedChildren;\n  }\n\n\n  private _cacheChildren(element: HTMLElement) {\n    const nodes = element.childNodes,\n      children: Node[] = [];\n    let i = nodes.length;\n\n    while (i--) {\n      if (nodes[i].nodeType === 1) {\n        children.unshift(nodes[i]);\n      }\n    }\n\n    this._cachedChildren = children;\n  }\n\n\n  private _mapChildren(children: TagChildren): Node[] {\n    const mapped: Node[] = [];\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      // for (const child of children) {\n      if (child instanceof CTag) {\n        child.parent = this;\n      }\n\n      if (this._childrenFilterPredicate(child)) {\n        const element = this._getElementForChild(child);\n        if (element != null) mapped.push(element);\n      }\n    }\n    return mapped;\n  }\n}\n\n/**\n * This function can do the following based on the first argument:\n * * create a tag if you provide a tag name: (`div`, `abbr`, `custom-tag`, ...),\n * * wrap around an existing element in the page if you pass in a selector: (`'(body)'`, `'(#id)'`, `'(.class)'`), any selector is allowed.\n * * wrap around an element passed in\n *\n * Then it can receive a list of children to be added.\n * Receives a third argument for mounting this tag to the currently mounted tag ({@link context.mp}).\n *\n * @example\n * ```ts\n * tag('div');\n * tag('(body)');\n * tag('(.someclass)');\n * tag(document.querySelector('#something'));\n * ```\n */\nexport const tag = (arg0: string | HTMLElement, children: TagChildren = [], mountToParent: boolean = false) => {\n  checkInitialized();\n  return new CTag(arg0, children, mountToParent);\n};\n","import type { NestedStyleMap } from './types';\nimport { camelToDash, isObject } from './util.js';\n\nexport const genCss = (\n  styleSheet:\n    | Record<string, NestedStyleMap>\n    | Array<Record<string, NestedStyleMap>>,\n) => {\n  const stylesheets = styleSheet instanceof Array ? styleSheet : [styleSheet];\n  let generatedCss = '';\n\n  for (const sheet of stylesheets) {\n    for (const key in sheet) {\n      generatedCss += genBlock(key, sheet[key]);\n    }\n  }\n  return generatedCss;\n};\n\nexport const genBlock = (selector: string, style: NestedStyleMap): string => {\n  return genBlockContent(selector, style).join('');\n};\n\nexport const genBlockContent = (\n  selector: string,\n  style: NestedStyleMap,\n): string[] => {\n  let inside = '';\n  const blocks: string[] = [];\n\n  for (const key in style) {\n    if (isObject(style[key])) {\n      let newSelector = selector;\n\n      newSelector += key;\n\n      blocks.push(...genBlockContent(newSelector, style[key] as NestedStyleMap));\n    }\n    else if (style[key]) {\n      inside += `${camelToDash(key)}:${style[key] as string};`;\n    }\n  }\n\n  blocks.unshift(`${selector}{${inside}}`);\n\n  return blocks;\n};\n","import { genCss } from \"./css-generator.js\";\nimport { tag, CTag } from \"./tag.js\";\nimport { NestedStyleMap } from \"./types.js\";\n\nconst STYLE_TAG_ID = 'cardboard-styles';\n\nexport class StyleManager {\n    styleTag: CTag;\n    rules: Set<string>;\n\n    generatedIdsCount: number = 0;\n\n    constructor() {\n        this.rules = new Set();\n        let styleTag: CTag | null = null;\n\n        try {\n            styleTag = tag(`(#${STYLE_TAG_ID})`);\n        } catch (error) {\n            styleTag = tag('style').setId(STYLE_TAG_ID);\n        }\n\n        tag('(head)').append(styleTag);\n\n        this.styleTag = styleTag;\n    }\n\n    public add(styleSheet: Record<string, NestedStyleMap> | Array<Record<string, NestedStyleMap>>) {\n        const css = genCss(styleSheet);\n\n        if (!this.rules.has(css)) {\n            this.rules.add(css);\n            this.styleTag.append(css);\n        }\n    }\n}\n","import type { IObservable, State } from './types';\nimport { createObservable, getValue } from './observables.js';\n\n/**\n * `state` creates a reactive value that can the be used with tags to create dinamic and reactive apps.\n *\n * @see https://github.com/nombrekeff/cardboard-js/wiki/State\n *\n * @example\n * ```ts\n * const count = state(0);\n * count.changed(() => { ... });\n * count.dispatch(2);\n * count.value++;\n *\n * div().hideIf(count);\n * div().disableIf(count);\n * div(template('Count is: $count', { count: count }));\n * ```\n */\nexport const state = <T>(initialValue: T): State<T> => {\n  return createObservable(initialValue);\n};\n\n/**\n * `listState` creates a reactive list of values that can be used with tags to manage dynamic and reactive apps.\n * It wraps each item with a {@link State} (aka. {@link IObservable}) to allow for individual item reactivity.\n * @see https://github.com/nombrekeff/cardboard-js/wiki/ListState\n *\n * @example\n * ```javascript\n * const myList = listState([1, 2, 3]);\n *\n * myList.add(4);\n * myList.addAt(0, 0);\n * myList.remove(2);\n * myList.removeWhere(item => item === 3);\n * const listValues = myList.listValue;\n * const listLength = myList.length;\n *\n * // Listen to changes in the list\n * myList.list.changed(() => {\n *   // List has changed\n * });\n * ```\n */\nexport const listState = <T>(initialData: T[]) => {\n  const _list = state<Array<State<T>>>(\n    initialData.map((d) => createObservable(d)),\n  );\n\n  const add = (item: T) => {\n    stateAdd(_list, createObservable(item));\n  };\n\n  const addAt = (item: T, index: number) => {\n    stateAddAt(_list, createObservable(item), index);\n  };\n\n  return {\n    /**\n     * The reactive list of items.\n     * Each item is wrapped in a {@link State} to allow for individual reactivity.\n     */\n    get list() {\n      return _list;\n    },\n    /**\n     * The raw list of items.\n     */\n    get listValue() {\n      return _list.value;\n    },\n    add,\n    addAt,\n    remove: stateRemove.bind({}, _list),\n    removeWhere: stateRemoveWhere.bind({}, _list),\n    length: _list.computed((_list) => _list.length),\n  };\n};\n/**\n * `stateAdd` adds an item to a reactive list.\n * It creates a new array with the existing items and the new item, then updates the state.\n * \n * @example\n * ```typescript\n * const myList = state([]);\n * stateAdd(myList, 'new item');\n * ```\n */\nexport const stateAdd = <T>(state: State<T[]>, item: T) => {\n  state.value = [...state.value, item];\n};\n\n/**\n * `stateAddAt` adds an item to a reactive list at a specific index.\n * It creates a new array with the existing items and the new item at the specified index, then updates the state.\n * \n * @example\n * ```typescript\n * const myList = state([]);\n * stateAddAt(myList, 'new item', 0);\n * ```\n */\nexport const stateAddAt = <T>(state: State<T[]>, item: T, index: number) => {\n  let newData: any = [...state.value];\n  newData.splice(index, 0, item);\n  state.value = newData;\n  newData = [];\n};\n\n/**\n * `stateRemoveWhere` removes items from a reactive list based on a callback function.\n * It filters the list and updates the state with the remaining items.\n * \n * @example\n * ```typescript\n * const myList = state([1, 2, 3, 4]);\n * stateRemoveWhere(myList, (item) => item % 2 === 0); // Removes even numbers\n * ```\n */\nexport const stateRemoveWhere = <T>(state: State<T[]>, cb: (item: T, index: number) => boolean) => {\n  state.value = state.value.filter((el, i) => !cb(el, i));\n};\n\n/**\n * `stateRemove` removes a specific item from a reactive list.\n * It finds the index of the item in the list and calls `stateRemoveWhere` to remove it.\n * \n * @example\n * ```typescript\n * const myList = state([1, 2, 3, 4]);\n * stateRemove(myList, 2); // Removes the item with value 2\n * ```\n */\nexport const stateRemove = <T>(state: State<T[]>, item: T) => {\n  const index = state.value.findIndex(state => getValue(state) === getValue(item));\n  stateRemoveWhere(state, (_, i) => {\n    return index === i;\n  });\n};\n","import { isObservable } from './observables.js';\nimport { deepEquals } from './util.js';\nimport type { CTag } from './tag.js';\nimport type { IObservable, IObservableOr } from './types.js';\n\n/**\n * @enum {string}\n * @property {string} unchanged - The entry is unchanged.\n * @property {string} added - The entry was added.  \n * @property {string} removed - The entry was removed.\n * @property {string} swap - The entry was swapped with another entry.\n */\nexport enum DiffState {\n  unchanged = 'unchanged',\n  added = 'added',\n  removed = 'removed',\n  swap = 'swap',\n}\n\n/**\n * Represents a single entry in the diff process.\n * This interface is used to describe the state of an entry in the diff process,\n * including its index, the entry itself, and optionally the target entry and target index if it was swapped.\n * @property {DiffState} state - The state of the entry in the diff process.\n * @property {number} index - The index of the entry in the old data.\n * @property {T} entry - The entry itself.\n * @property {T} targetEntry - The target entry if the entry was swapped\n * @property {number} targetIndex - The index of the target entry if the entry was swapped.\n */\nexport interface DiffEntry<T = unknown> {\n  state: DiffState,\n  index: number,\n  entry: T,\n  targetEntry?: T;\n  targetIndex?: number,\n}\n\n/**\n * Render a {@link CTag} for each item in the provided list.\n *\n * `each` can work with a goold old array, or with a {@link IObservable}.\n * If you provide a `Observable`, the list will update whenever the `Observable` changes.\n *\n * @param observable - An array or an {@link IObservable} that contains the list of items to render.\n * @param builder - A function that takes an item from the list and returns a {@link CTag} to render.\n * @param key - An optional function that returns a unique key for each item in the list. This is used to optimize the rendering process.\n * \n * @see https://github.com/nombrekeff/cardboard-js/wiki/Logic\n *\n * @example\n * Static list\n * ```ts\n * const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n * div(\n *     each(colors, (color) =>\n *        button(color).addStyle('color', color)\n *     )\n * );\n * ```\n *\n * @example\n * Dynamic list\n * ```ts\n *  const colors = state(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']);\n *  const selectedColor = state('red');\n *  div(\n *    each(colors, (color) =>\n *        button(color)\n *         .addStyle('color', color)\n *         .stylesIf(equalTo(selectedColor, color), { fontWeight: 'bold' });\n *    )\n *  );\n * ```\n */\nexport function each<T>(\n  observable: IObservableOr<T[]>,\n  builder: (val: T) => CTag,\n  key?: (val: T) => any,\n): Node {\n  const node = document.createTextNode(''), elements: CTag[] = [];\n  let oldData: T[] = [],\n    nodeParentIndex: number = 0,\n    elementsCopy: CTag[] = [];\n\n  // Inserts a new element into the DOM and the elements array at the specified index.\n  // Uses the transform function to create the element and places it before the next sibling or anchor node.\n  const actionAdd = (entry: DiffEntry<T>) => {\n    if (entry.index >= 0) {\n      const el = builder(entry.entry);\n      const elAt = elements[entry.index];\n      elements.splice(entry.index, 0, el);\n      node.parentElement?.insertBefore(el.el, elAt ? elAt.el : node);\n    }\n  };\n\n  // Removes the element at the specified index from the DOM and calls its destroy method.\n  // Also removes the element from the internal elements array to keep it in sync.\n  const actionRemove = (entry: DiffEntry<T>) => {\n    node.parentElement?.removeChild(elementsCopy[entry.index].el);\n    elementsCopy[entry.index].destroy();\n\n    // This is done because if we use the original index, and the array changes size,\n    // the indexes will not match\n    const i = elements.indexOf(elementsCopy[entry.index]);\n    elements.splice(i, 1);\n  };\n\n  // Swaps two elements in the DOM and updates their positions in the internal arrays.\n  // Ensures the visual order matches the new data order after a swap operation.\n  const actionSwap = (entry: DiffEntry<T>) => {\n    const fromIndex = entry.index,\n      toIndex = entry.targetIndex ?? 0;\n\n    if (fromIndex >= 0 && toIndex >= 0) {\n      const elementFrom = elementsCopy[fromIndex];\n      const elementTo = elementsCopy[toIndex];\n\n      const parentNode = elementFrom.el.parentNode;\n      const nextSiblingNode = elementFrom.el.nextSibling;\n\n      if (parentNode && nextSiblingNode === elementTo.el) {\n        parentNode.insertBefore(elementTo.el, elementFrom.el);\n      }\n      else if (elementTo.el.parentNode) {\n        elementTo.el.parentNode.insertBefore(elementFrom.el, elementTo.el);\n\n        if (nextSiblingNode && parentNode) {\n          parentNode.insertBefore(elementTo.el, nextSiblingNode);\n        }\n        else if (parentNode) {\n          parentNode.appendChild(elementTo.el);\n        }\n      }\n\n      const tempCopy = elementsCopy[fromIndex];\n      elementsCopy[fromIndex] = elementsCopy[toIndex];\n      elementsCopy[toIndex] = tempCopy;\n\n      const temp = elements[fromIndex];\n      elements[fromIndex] = elements[toIndex];\n      elements[toIndex] = temp;\n    }\n  };\n\n  // Map of actions to perform based on the diff state\n  // This is used to avoid using a switch statement, which is slower\n  // and to keep the code cleaner.\n  const actionMap = {\n    [DiffState.added]: actionAdd,\n    [DiffState.removed]: actionRemove,\n    [DiffState.swap]: actionSwap,\n  };\n\n  // Maximum number of tries to find the parent element\n  // This is used to avoid infinite loops in case the parent element is not found\n  const MAX_UPDATE_TRIES = 100;\n\n  // This function updates the list of elements based on the new data.\n  // It calculates the differences between the old and new data using `diffList`,\n  // and applies the necessary actions to the DOM.\n  const updateList = (newData: T[], tries = 0) => {\n    // If the node has no parent element, it means it has not been mounted yet,\n    // so we wait a bit and try again.\n    if (!node.parentElement) {\n      // If we have not reached the max tries, we wait a bit and try again\n      if (tries < MAX_UPDATE_TRIES) {\n        setTimeout(() => updateList(newData, tries + 1), 1);\n      } else {\n        console.warn(`[each]: parentElement not found after max retries`);\n      }\n      return;\n    }\n\n    if (!nodeParentIndex) {\n      const children = Array.from(node.parentElement?.childNodes ?? []);\n      nodeParentIndex = children.indexOf(node);\n    }\n\n    // Create the diff between the new data and the old data\n    const diff = diffList(newData, oldData, key);\n\n    // If the diff is empty, it means the data has not changed, so we do nothing\n    if (diff.length <= 0) return;\n\n    // Process the diff and apply the actions\n    for (let index = 0; index < diff.length; index++) {\n      const data = diff[index];\n      const nextIndex = diff[index + 1] ? diff[index + 1].index : null;\n      const nextState = diff[index + 1] ? diff[index + 1].state : null;\n      actionMap[data.state](data);\n      if (nextState === DiffState.swap && nextIndex === data.targetIndex) {\n        index++;\n      }\n    }\n\n    // Set the new data as the old data for the next update\n    oldData = [...newData].slice(0);\n\n    // Update the elementsCopy to match the new data\n    elementsCopy = elements.slice(0);\n  };\n\n  updateList('value' in observable ? observable.value : observable);\n\n  if (isObservable(observable)) {\n    (observable as IObservable).changed(updateList);\n  }\n\n  return node;\n}\n\n/**\n * Compares 2 lists, returns an array of {@link DiffEntry} with the operations needed to make in the `oldData` to create the new list.\n * It only returns the actions that are needed, if an element does not need to move, then it's not returned\n * \n * @param newData - The new data to compare against the old data.\n * @param oldData - The old data to compare against the new data.\n * @param key - A function that returns a unique key for each item in the list. This is used to optimize the rendering process.\n * @returns An array of {@link DiffEntry} objects that describe the differences between the two lists.\n */\nexport function diffList<T>(\n  newData: T[], oldData: T[],\n  key: (item: T) => any = (item: T) => item\n): Array<DiffEntry<T>> {\n  const diff: Array<DiffEntry<T>> = [],\n    newLength = newData.length,\n    oldLength = oldData.length;\n\n  // If the data is the same, don't do anything\n  if (newLength === oldLength && (newData == oldData || deepEquals(oldData, newData))) {\n    return diff;\n  }\n\n  // If all items have been removed, just remove them, no need to diff\n  if (newLength <= 0) {\n    for (let i = 0; i < oldLength; i++) {\n      diff[i] = {\n        entry: oldData[i],\n        state: DiffState.removed,\n        index: i,\n      };\n    }\n    return diff;\n  }\n\n  // If there was no data before, add all items\n  if (!oldLength) {\n    for (let i = 0; i < newLength; i++) {\n      diff[i] = {\n        entry: newData[i],\n        state: DiffState.added,\n        index: i,\n      };\n    }\n    return diff;\n  }\n\n  // Count of how many items have been removed so far (inside the loop)\n  let removedCount = 0;\n\n  // diff the old data with the new one\n  for (let oi = 0; oi < oldLength; oi++) {\n    const newEntry = newData[oi - removedCount],\n      oldEntry = oldData[oi],\n      areEqual = key(oldEntry) == key(newEntry);\n\n    if (areEqual || deepEquals(oldEntry, newEntry)) {\n      continue;\n    }\n\n    const existsNew = !!newData.find(item => key(oldEntry) == key(item)),\n      existsOld = !!oldData.find(item => key(newEntry) == key(item));\n\n    // If the new entry does not exist in the old data, it means it was added\n    if (!existsOld && existsNew) {\n      diff.push({\n        entry: newEntry,\n        state: DiffState.added,\n        index: oi - removedCount,\n      });\n      removedCount--;\n      continue;\n    }\n\n    // If the old entry does not exist in the new data, it means it was removed\n    // `newEntry` can be undefined if the newData is shorter than the oldData\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    if ((existsOld && !existsNew) || newEntry == null) {\n      diff.push({\n        entry: oldEntry,\n        state: DiffState.removed,\n        index: oi,\n      });\n      removedCount++;\n      continue;\n    }\n\n    // If the new entry exists in the old data, it means it was swapped\n    if (newData.indexOf(oldEntry) >= 0) {\n      diff.push({\n        entry: newEntry,\n        targetEntry: oldEntry,\n        state: DiffState.swap,\n        index: oldData.indexOf(newData[oi - removedCount]),\n        targetIndex: oldData.indexOf(oldData[oi]),\n      });\n\n      // This swaps items, this is needed to create cohesive swapping\n      const oldIndex = oldData.indexOf(newEntry);\n      const temp = oldData[oi];\n      oldData[oi] = newData[oi - removedCount];\n      oldData[oldIndex] = temp;\n    }\n  }\n\n  // Add any new items that were not in the old data\n  if (removedCount != oldLength) {\n    for (let i = oldLength - removedCount; i < newLength; i++) {\n      const newEntry = newData[i];\n      diff.push({\n        entry: newEntry,\n        state: DiffState.added,\n        index: i,\n      });\n    }\n  }\n\n  return diff;\n}\n","import { context, createGlobalObserver } from './cardboard.js';\nimport { type CTag } from './tag.js';\nimport { type AtLeastOne } from './types.js';\n\n\n/**\n * Will call {mounted} when the element is added to the DOM.\n * And will call {beforeUnmounted} before the element is removed from the DOM.\n * Finally will call {onUnmounted} when the element is removed from the DOM.\n */\nexport function onLifecycle(\n    tag: CTag,\n    onMounted?: (tag: CTag) => Promise<boolean> | boolean,\n    onUnmounted?: (tag: CTag) => void,\n    beforeUnmounted?: (tag: CTag) => Promise<boolean> | boolean,\n) {\n    if (beforeUnmounted) {\n        const tempElRemove = tag.el.remove;\n        tag.el.remove = async () => {\n            const result = beforeUnmounted(tag);\n            if (!result || (result instanceof Promise && (await result))) {\n                tempElRemove.call(tag.el);\n            }\n            return result.valueOf();\n        };\n    }\n\n    if (onMounted) {\n        const tempOnStart = tag.show;\n        tag.show = async () => {\n            const result = tempOnStart.call(tag);\n            if (result instanceof Promise) {\n                return await result;\n            }\n            return result;\n        };\n    }\n\n    context.obs ??= createGlobalObserver();\n\n    const onAddedCb = async (node: Node) => {\n        let isAdded = node === tag.el || node.contains(tag.el);\n        if (isAdded && onMounted) {\n            const result = onMounted(tag);\n            if (result instanceof Promise) {\n                await result;\n            }\n        }\n    }\n    const onRemovedCb = (node: Node) => {\n        let isRemoved = node === tag.el || node.contains(tag.el);\n        if (isRemoved && onUnmounted) {\n            onUnmounted(tag);\n        }\n    };\n    context.obs.onAdded.listen(onAddedCb);\n    context.obs.onRemoved.listen(onRemovedCb);\n\n    // Using `any` here to avoid TypeScript errors, as `_destroyers` is not typed in the CTag interface.\n    (tag as any)._destroyers.push(() => {\n        // Remove listeners and references (clear memory)\n        context.obs?.onRemoved.remove(onRemovedCb);\n        context.obs?.onAdded.remove(onAddedCb);\n        onUnmounted = undefined;\n        onMounted = undefined;\n    });\n};\n\n/**\n * `withLifecycle` is a utility function that adds lifecycle hooks to a Cardboard tag.\n * \n * Will call `handler.mounted` when the element is added to the DOM.  \n * Then call `handler.beforeUnmount` **before** the element is removed from the DOM.  \n * Finally call `handler.unmounted` **when** the element is removed from the DOM.  \n * \n * @example\n * ```typescript\n * const myTag = withLifecycle(\n *   div('Hello World'),\n *   {\n *     mounted: (tag) => {\n *       console.log('Mounted:', tag);\n *       return true; // or false to prevent mounting\n *     },                                       \n *     unmounted: (tag) => {\n *       console.log('Unmounted:', tag);\n *     },\n *     beforeUnmount: (tag) => {\n *       console.log('Before Unmount:', tag);\n *       return true; // or false to prevent unmounting\n *     },\n *    }\n *  );\n */\nexport const withLifecycle = (\n    tag: CTag,\n    handler: AtLeastOne<{\n        // Add object here so handlers can be seen when instecting the `withLifecycle` function.\n        // This is useful for IDEs to show the available properties.\n        mounted?: (tag: CTag) => Promise<boolean> | boolean;\n        unmounted?: (tag: CTag) => void;\n        beforeUnmounted?: (tag: CTag) => Promise<boolean> | boolean;\n    }>,\n): CTag => {\n    onLifecycle(tag, handler.mounted, handler.unmounted, handler.beforeUnmounted);\n    return tag;\n};\n","import { genCss } from \"./css-generator.js\";\nimport { CTag, tag } from \"./tag.js\";\nimport type { AllTags, StyleSet, TagBuilder, TagChildren } from \"./types.js\";\n\n\n/** Override any tag function we want, to give it some custom behaviour, process the children, etc... */\nconst interceptors: Record<string, TagBuilder | ((styles: StyleSet[]) => CTag)> = {\n  ul: (children: TagChildren, mountToParent: boolean = false) => {\n    return tag(\n      'ul',\n      children.map((cl) => {\n        return tag('li', [cl], mountToParent);\n      }),\n    );\n  },\n  style: (styles: StyleSet[], mountToParent: boolean = false) => {\n    return tag('style', [genCss(styles)], mountToParent);\n  },\n};\n\n/**\n * List of all HTML tag functions. From `div` to `abbr` :)\n * If you want to create any other tag, use the {@link tag} function.\n *\n * @type {AllTags}\n * @example\n * ```ts\n * const { div, p, abbr, img, style, ... } = allTags;\n * ```\n */\nexport const allTags: AllTags = new Proxy(\n  {},\n  {\n    get: (t, p, r) => {\n      const tagName = p.toString();\n      const fn = (...children: any[]) => {\n        return interceptors[tagName] ? interceptors[tagName](children, false) : tag(tagName, children);\n      };\n\n      Object.defineProperty(fn, 'mount', {\n        get: () => {\n          return (...children: any[]) => {\n            return interceptors[tagName] ? interceptors[tagName](children, true) : tag(tagName, children, true);\n          };\n        },\n      });\n\n      return fn;\n    },\n  },\n) as AllTags;\n"],"mappings":"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","names":["cardboard_exports","__export","CEvent","CMappedEvent","CTag","DiffState","Observable","allTags","arraysEqual","camelToDash","checkInitialized","clearMountPoints","compute","computeMultiple","context","createGlobalObserver","createObservable","deepEquals","diffList","each","equalTo","genBlock","genBlockContent","genCss","generateUID","getMountPoint","getValue","grab","greaterThan","greaterThanOr","init","isArray","isEmpty","isInitialized","isObject","isObservable","lessThan","lessThanOr","listState","mappedEvent","mountPoint","notEmpty","notEqualTo","onLifecycle","removeFromList","resetMountPoints","restoreMountPoint","singleEvent","state","stateAdd","stateAddAt","stateRemove","stateRemoveWhere","swapItems","tag","text","uuidv4","val","version","withLifecycle","withMountPoint","removeFromList","item","list","index","camelToDash","str","val","isObject","obj","isArray","args","swapItems","array","from","to","temp","arraysEqual","a","b","i","deepEquals","length","keys","key","generateUID","idNumber","uuidv4","c","CEvent","fn","removeFromList","data","el","CMappedEvent","evt","singleEvent","mappedEvent","context","isInitialized","checkInitialized","getMountPoint","mountPoint","tag","restoreMountPoint","clearMountPoints","resetMountPoints","first","withMountPoint","scopedCallback","createGlobalObserver","_addedEvt","singleEvent","_removedEvt","observer","mutations","mut","n","Observable","CEvent","val","destroyer","transform","compute","greaterThan","greaterThanOr","lessThan","lessThanOr","equalTo","notEqualTo","isEmpty","notEmpty","key","defaultVal","grab","isObject","isArray","target","p","receiver","newValue","callback","isObservable","obj","createObservable","other","observable","cb","computeMultiple","observables","cons","c","getValue","newVal","text","textTemplate","obj","node","interpolatePattern","updateNode","data","m","g1","_a","isObservable","val","isObject","key","CTag","_CTag","arg0","children","mountToParent","isSelector","match","selector","element","context","newValue","newParent","checked","value","id","__async","parentEl","expectedIndex","hiddenBefore","child","nextEl","observable","callback","cb","ifTrue","ifFalse","invert","temp","_","handleHide","correctedValue","classes","val","text","elseText","attr","style","styles","stylesheet","className","_a","uuidv4","textTemplate","obj","c","key","targetClass","replaceClass","property","styleNames","camelToDash","attrs","tag","evt","consumer","other","evtName","fn","cons","createObservable","t","listener","result","cl","disabled","predicate","item","isObservable","nodes","i","mapped","checkInitialized","genCss","styleSheet","stylesheets","generatedCss","sheet","key","genBlock","selector","style","genBlockContent","inside","blocks","isObject","newSelector","camelToDash","STYLE_TAG_ID","StyleManager","styleTag","tag","error","styleSheet","css","genCss","state","initialValue","createObservable","listState","initialData","_list","d","add","item","stateAdd","addAt","index","stateAddAt","stateRemove","stateRemoveWhere","newData","cb","el","i","getValue","_","DiffState","each","observable","builder","key","node","elements","oldData","nodeParentIndex","elementsCopy","actionAdd","entry","_a","el","elAt","actionRemove","i","actionSwap","fromIndex","toIndex","elementFrom","elementTo","parentNode","nextSiblingNode","tempCopy","temp","actionMap","MAX_UPDATE_TRIES","updateList","newData","tries","_b","children","diff","diffList","index","data","nextIndex","nextState","isObservable","item","newLength","oldLength","deepEquals","removedCount","oi","newEntry","oldEntry","areEqual","existsNew","existsOld","oldIndex","onLifecycle","tag","onMounted","onUnmounted","beforeUnmounted","_a","_b","tempElRemove","__async","result","tempOnStart","context","createGlobalObserver","onAddedCb","node","isAdded","onRemovedCb","isRemoved","withLifecycle","tag","handler","onLifecycle","interceptors","children","mountToParent","tag","cl","styles","genCss","allTags","t","p","r","tagName","fn","init","options","context","createGlobalObserver","StyleManager","tag","CTag","mountPoint","version"]}